from constants import NUCLEOTIDES

class Echantillon:

    @staticmethod
    def create_sequence(size: int) -> str:
        """
            Crée une séquence d'ADN aléatoire de taille donnée.

            Param size: Taille de la séquence à créer.
            Return : Une chaîne de caractères représentant la séquence d'ADN.
        """
        import random
        # Initialisation de la séquence vide
        sequence : str = ''
        # Génération de la séquence aléatoire grâce au module random
        for _ in range(size):
            sequence += random.choice(NUCLEOTIDES)
        
        return sequence
    
    @staticmethod
    def mutation_replacement(sequence: str, mut_probability: float) -> str:
        """
            Applique une mutation de remplacement sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param mut_probability: La probabilité de remplacement pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < mut_probability:
                # Choisir un nouveau nucléotide différent de l'original
                possible_nucleotides: list[str] = [bases for bases in NUCLEOTIDES if bases != nucleotide]
                new_nucleotide: str = random.choice(possible_nucleotides)
                mutated_sequence += new_nucleotide
            else:
                mutated_sequence += nucleotide
        
        return mutated_sequence

    @staticmethod
    def mutation_deletion(sequence: str, del_probability: float) -> str:
        """
            Applique une mutation de délétion sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param del_probability: La probabilité de délétion pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence: str = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < del_probability:
                continue
            else:
                mutated_sequence += nucleotide
        
        return mutated_sequence
    
    @staticmethod
    def mutation_insertion(sequence: str, ins_probability: float) -> str:
        """
            Applique une mutation d'insertion sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param ins_probability: La probabilité d'insertion pour chaque position entre les nucléotides (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence: str = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < ins_probability:
                # Insérer un nouveau nucléotide aléatoire avant le nucléotide actuel
                new_nucleotide: str = random.choice(NUCLEOTIDES)
                mutated_sequence += new_nucleotide
            mutated_sequence += nucleotide
        
        # Possibilité d'ajouter un nucléotide à la fin de la séquence
        if random.uniform(0, 1) < ins_probability:
            new_nucleotide: str = random.choice(NUCLEOTIDES)
            mutated_sequence += new_nucleotide
        
        return mutated_sequence


    @staticmethod
    def mutation(sequence: str, replacement_probability: float, insertion_probability: float, deletion_probability: float) -> str:
        """
            Applique des mutations sur une séquence d'ADN avec des probabilités données pour chaque type de mutation.

            Param sequence: La séquence d'ADN à muter.
            Param del_probability: La probabilité de délétion pour chaque nucléotide (entre 0 et 1).
            Param ins_probability: La probabilité d'insertion pour chaque position entre les nucléotides (entre 0 et 1).
            Param rep_probability: La probabilité de remplacement pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence = ''

        for nucleotide in sequence:
            random_value = random.uniform(0, 1)

            if random_value < replacement_probability:
                possible_nucleotides: list[str] = [bases for bases in NUCLEOTIDES if bases != nucleotide]
                new_nucleotide: str = random.choice(possible_nucleotides)
                mutated_sequence += new_nucleotide

            # valeur aléatoire comprise entre replacement_probability et replacement_probability + insertion_probability
            # mais la borne inferieure est vérifiée en premier donc pas besoin de la vérifier à nouveau
            elif random_value < replacement_probability + insertion_probability:

                new_nucleotide: str = random.choice(NUCLEOTIDES)
                mutated_sequence += new_nucleotide 
                mutated_sequence += nucleotide

            elif random_value < replacement_probability + insertion_probability + deletion_probability:
                # Suppression : ne rien ajouter (le nucléotide est supprimé)
                continue

            else:
                # Aucun changement : ajouter le nucléotide original
                mutated_sequence += nucleotide

    @staticmethod
    def mutation_replacement_distance(sequence1: str, sequence2 : str) -> int:
        """
            Compare deux séquences ADN et retourne la distance entre les deux séquences.

            param sequence1: La première séquence ADN à comparer.
            param sequence2: La deuxieme séquence ADN à comparer.
            return: La distance des deux fichiers
        """
        distance_lenght = 0
        seq1_lenght = len(sequence1)
        seq2_lenght = len(sequence2)
        # On regarde quelle est la séquence la plus grande, Si il y a une séquence plus grande que l'autre 
        if seq1_lenght > seq2_lenght:
            distance_lenght += seq1_lenght - seq2_lenght # on ajoute la différence de longueur à la distance puis
            for base_pos in range(seq2_lenght):          # on boucle sur la séquence la plus petite 
                if sequence1[base_pos] != sequence2[base_pos]:
                    distance_lenght += 1
        else: 
            distance_lenght += seq2_lenght - seq1_lenght
            for base_pos in range(seq1_lenght):
                if sequence1[base_pos] != sequence2[base_pos]:
                    distance_lenght += 1
        return distance_lenght


def main():
    # Exemple d'utilisation
    echantillon = Echantillon.create_sequence(100)
    echantillon_replaced = Echantillon.mutation_replacement(echantillon, 0.2)
    echantillon_mutated = Echantillon.mutation(echantillon, 0.3, 0.1, 0.2)
    print(echantillon)
    print(echantillon_mutated)
    print(Echantillon.mutation_replacement_distance(echantillon, echantillon_replaced))

if __name__ == "__main__":
    main()