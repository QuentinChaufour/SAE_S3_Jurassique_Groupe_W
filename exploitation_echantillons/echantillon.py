from constants import NUCLEOTIDES

class Echantillon:

    @staticmethod
    def create_sequence(size: int) -> str:
        """
            Crée une séquence d'ADN aléatoire de taille donnée.

            Param size: Taille de la séquence à créer.
            Return : Une chaîne de caractères représentant la séquence d'ADN.
        """
        import random
        # Initialisation de la séquence vide
        sequence : str = ''
        # Génération de la séquence aléatoire grâce au module random
        for _ in range(size):
            sequence += random.choice(NUCLEOTIDES)
        
        return sequence
    
    @staticmethod
    def mutation_replacement(sequence: str, mut_probability: float) -> str:
        """
            Applique une mutation de remplacement sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param mut_probability: La probabilité de remplacement pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < mut_probability:
                # Choisir un nouveau nucléotide différent de l'original
                possible_nucleotides: list[str] = [bases for bases in NUCLEOTIDES if bases != nucleotide]
                new_nucleotide: str = random.choice(possible_nucleotides)
                mutated_sequence += new_nucleotide
            else:
                mutated_sequence += nucleotide
        
        return mutated_sequence

    @staticmethod
    def mutation_deletion(sequence: str, del_probability: float) -> str:
        """
            Applique une mutation de délétion sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param del_probability: La probabilité de délétion pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence: str = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < del_probability:
                continue
            else:
                mutated_sequence += nucleotide
        
        return mutated_sequence
    
    @staticmethod
    def mutation_insertion(sequence: str, ins_probability: float) -> str:
        """
            Applique une mutation d'insertion sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param ins_probability: La probabilité d'insertion pour chaque position entre les nucléotides (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence: str = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < ins_probability:
                # Insérer un nouveau nucléotide aléatoire avant le nucléotide actuel
                new_nucleotide: str = random.choice(NUCLEOTIDES)
                mutated_sequence += new_nucleotide
            mutated_sequence += nucleotide
        
        # Possibilité d'ajouter un nucléotide à la fin de la séquence
        if random.uniform(0, 1) < ins_probability:
            new_nucleotide: str = random.choice(NUCLEOTIDES)
            mutated_sequence += new_nucleotide
        
        return mutated_sequence


    @staticmethod
    def mutation(sequence: str, replacement_probability: float, insertion_probability: float, deletion_probability: float) -> str:
        """
            Applique des mutations sur une séquence d'ADN avec des probabilités données pour chaque type de mutation.

            Param sequence: La séquence d'ADN à muter.
            Param del_probability: La probabilité de délétion pour chaque nucléotide (entre 0 et 1).
            Param ins_probability: La probabilité d'insertion pour chaque position entre les nucléotides (entre 0 et 1).
            Param rep_probability: La probabilité de remplacement pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        import random
        mutated_sequence = ''

        for nucleotide in sequence:
            random_value = random.uniform(0, 1)

            if random_value < replacement_probability:
                possible_nucleotides: list[str] = [bases for bases in NUCLEOTIDES if bases != nucleotide]
                new_nucleotide: str = random.choice(possible_nucleotides)
                mutated_sequence += new_nucleotide

            # valeur aléatoire comprise entre replacement_probability et replacement_probability + insertion_probability
            # mais la borne inferieure est vérifiée en premier donc pas besoin de la vérifier à nouveau
            elif random_value < replacement_probability + insertion_probability:

                new_nucleotide: str = random.choice(NUCLEOTIDES)
                mutated_sequence += new_nucleotide 
                mutated_sequence += nucleotide

            elif random_value < replacement_probability + insertion_probability + deletion_probability:
                # Suppression : ne rien ajouter (le nucléotide est supprimé)
                continue

            else:
                # Aucun changement : ajouter le nucléotide original
                mutated_sequence += nucleotide
                
        return mutated_sequence

    @staticmethod
    def levenshtein(inital_sequence: str, compared_sequence: str) -> int:
        """
            Calcule la distance entre 2 chaines en utilisant l'algorithme de levanshtein

            Param inital_sequence: la sequence utilisé pour la base de la comparaison
            Param compared_sequence: la sequence comparé a la sequence initiale

            Return : la distance minimale séparant les 2 chaines de caractères
        """
        
        # Si l'une des 2 sequence est vide alors la distance est la taille de l'autre sequence
        inital_sequence_lenght: int = len(inital_sequence)
        compared_sequence_lenght: int = len(compared_sequence) 
        if min(inital_sequence_lenght,compared_sequence_lenght) == 0:
            return max(inital_sequence_lenght,compared_sequence_lenght)

        # tableau de levenshtein
        distance_matrice: list[list[int]] = []

        # initialisation du tableau 
        for _ in range(compared_sequence_lenght):
            distance_matrice.append([])

        # coin haut gauche a 0 car aucune action pour passer de chaine vide 
        # a une autre chaine vide
        distance_matrice[0].append(0)
            
        for i in range(1,inital_sequence_lenght):
            # initialisation de la ligne pour les distances avec une chaine vide
            distance_matrice[0].append(i)

        for j in range(1,compared_sequence_lenght):
            # initialisation de la colonne pour les distances avec une chaine vide
            distance_matrice[j].append(j)
        
        for line in range(1,compared_sequence_lenght):
            for column in range(1,inital_sequence_lenght):

                # coût d'action a 1
                cost: int = 1
                corner_distance = distance_matrice[line-1][column-1]
                up_line_distance = distance_matrice[line-1][column]
                right_column_distance = distance_matrice[line][column -1]
                
                if inital_sequence[i] == compared_sequence[j]:
                    cost = 0    # pas besoin de changement les valeurs
                
                distance: int = min(corner_distance,up_line_distance,right_column_distance) + cost
                distance_matrice[line].append(distance)

        return distance_matrice[compared_sequence_lenght -1][inital_sequence_lenght -1]

def main():
    print(Echantillon.levenshtein("chiens","niche"))

if __name__ == "__main__":
    main()