import random
from constants import NUCLEOTIDES
from espece_averee import EspeceAveree
from espece import EspeceHypothetique
import time

class Echantillon:

    @staticmethod
    def create_sequence(size: int) -> str:
        """
            Crée une séquence d'ADN aléatoire de taille donnée.

            Param size: Taille de la séquence à créer.
            Return : Une chaîne de caractères représentant la séquence d'ADN.
        """
        
        # Initialisation de la séquence vide
        sequence : str = ''
        # Génération de la séquence aléatoire grâce au module random
        for _ in range(size):
            sequence += random.choice(NUCLEOTIDES)
        
        return sequence
    
    @staticmethod
    def mutation_replacement(sequence: str, mut_probability: float) -> str:
        """
            Applique une mutation de remplacement sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param mut_probability: La probabilité de remplacement pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        
        mutated_sequence = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < mut_probability:
                # Choisir un nouveau nucléotide différent de l'original
                possible_nucleotides: list[str] = [bases for bases in NUCLEOTIDES if bases != nucleotide]
                new_nucleotide: str = random.choice(possible_nucleotides)
                mutated_sequence += new_nucleotide
            else:
                mutated_sequence += nucleotide
        
        return mutated_sequence

    @staticmethod
    def mutation_deletion(sequence: str, del_probability: float) -> str:
        """
            Applique une mutation de délétion sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param del_probability: La probabilité de délétion pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """
        
        mutated_sequence: str = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < del_probability:
                continue
            else:
                mutated_sequence += nucleotide
        
        return mutated_sequence
    
    @staticmethod
    def mutation_insertion(sequence: str, ins_probability: float) -> str:
        """
            Applique une mutation d'insertion sur une séquence d'ADN avec une certaine probabilité p.

            Param sequence: La séquence d'ADN à muter.
            Param ins_probability: La probabilité d'insertion pour chaque position entre les nucléotides (entre 0 et 1).
            Return : La séquence mutée.
        """
        
        mutated_sequence: str = ''
        
        for nucleotide in sequence:
            if random.uniform(0, 1) < ins_probability:
                # Insérer un nouveau nucléotide aléatoire avant le nucléotide actuel
                new_nucleotide: str = random.choice(NUCLEOTIDES)
                mutated_sequence += new_nucleotide
            mutated_sequence += nucleotide
        
        # Possibilité d'ajouter un nucléotide à la fin de la séquence
        if random.uniform(0, 1) < ins_probability:
            new_nucleotide: str = random.choice(NUCLEOTIDES)
            mutated_sequence += new_nucleotide
        
        return mutated_sequence


    @staticmethod
    def mutation(sequence: str, replacement_probability: float, insertion_probability: float, deletion_probability: float) -> str:
        """
            Applique des mutations sur une séquence d'ADN avec des probabilités données pour chaque type de mutation.

            Param sequence: La séquence d'ADN à muter.
            Param del_probability: La probabilité de délétion pour chaque nucléotide (entre 0 et 1).
            Param ins_probability: La probabilité d'insertion pour chaque position entre les nucléotides (entre 0 et 1).
            Param rep_probability: La probabilité de remplacement pour chaque nucléotide (entre 0 et 1).
            Return : La séquence mutée.
        """

        mutated_sequence = ''

        for nucleotide in sequence:
            random_value = random.uniform(0, 1)

            if random_value < replacement_probability:
                possible_nucleotides: list[str] = [bases for bases in NUCLEOTIDES if bases != nucleotide]
                new_nucleotide: str = random.choice(possible_nucleotides)
                mutated_sequence += new_nucleotide

            # valeur aléatoire comprise entre replacement_probability et replacement_probability + insertion_probability
            # mais la borne inferieure est vérifiée en premier donc pas besoin de la vérifier à nouveau
            elif random_value < replacement_probability + insertion_probability:

                new_nucleotide: str = random.choice(NUCLEOTIDES)
                mutated_sequence += new_nucleotide 
                mutated_sequence += nucleotide

            elif random_value < replacement_probability + insertion_probability + deletion_probability:
                # Suppression : ne rien ajouter (le nucléotide est supprimé)
                continue

            else:
                # Aucun changement : ajouter le nucléotide original
                mutated_sequence += nucleotide
                
        return mutated_sequence

    @staticmethod
    def levenshtein(initial_sequence: str, compared_sequence: str) -> int:
        """
            Calcule la distance entre 2 chaines en utilisant l'algorithme de levanshtein

            Param inital_sequence: la sequence utilisé pour la base de la comparaison
            Param compared_sequence: la sequence comparé a la sequence initiale

            Return : la distance minimale séparant les 2 chaines de caractères
        """
        
        # Si l'une des 2 sequence est vide alors la distance est la taille de l'autre sequence
        initial_sequence_length: int = len(initial_sequence)
        compared_sequence_length: int = len(compared_sequence)

        if min(initial_sequence_length,compared_sequence_length) == 0:
            return max(initial_sequence_length,compared_sequence_length)
        
        # séquence initiale la plus grande des 2 pour limiter le nombre d'itération
        if initial_sequence_length < compared_sequence_length:
            initial_sequence, compared_sequence = compared_sequence, initial_sequence
            initial_sequence_length, compared_sequence_length = compared_sequence_length, initial_sequence_length


        # dernière ligne a jour du tableau de levenshtein
        distance_row: list[list[int]] = list(range(compared_sequence_length + 1))

        
        for row, initial_char in enumerate(initial_sequence):

            current_row = [row + 1] + [0]*compared_sequence_length

            for column, compared_char in enumerate(compared_sequence):

                # coût d'action a 1
                cost: int = 1
                corner_distance = distance_row[column +1]
                up_line_distance = current_row[column]
                left_column_distance = distance_row[column]
                
                if initial_char == compared_char:
                    cost = 0    # pas besoin de changement les valeurs
                
                distance: int = min(corner_distance,up_line_distance,left_column_distance) + cost
                current_row[column +1] = distance
            
            distance_row = current_row

        return distance_row[-1]


    @staticmethod
    def mutation_replacement_distance(inital_sequence: str, compared_sequence : str) -> int:
        """
            Compare deux séquences ADN et retourne la distance entre les deux séquences.
            param sequence1: La première séquence ADN à comparer.
            param sequence2: La deuxieme séquence ADN à comparer.
            return: La distance des deux fichiers
        """
        distance = 0
        seq1_lenght = len(inital_sequence)
        seq2_lenght = len(compared_sequence)
        # on ajoute la différence de longueur à la distance
        distance += abs(seq1_lenght - seq2_lenght)
        # on boucle sur la séquence la plus petite 
        for i in range(min(seq2_lenght, seq1_lenght)):          
            if inital_sequence[i] != compared_sequence[i]:
                distance += 1
        return distance
    
    @staticmethod
    def sample_reader(path : str) -> str:
        """
            Lit un fichier .adn et retourne la séquence ADN sans les commentaires

            param path: Le chemin du fichier qu'on souhaite lire.
            return: La séquence ADN associé au fichier
        """
        sample = open(path)    
        block = sample.read(5000)
        cleaned_sample = []
        while len(block) != 0:
            cleaned_block = "".join([base for base in block if base in NUCLEOTIDES])
            cleaned_sample.append(cleaned_block)
            block = sample.read(5000)
        sample.close()
        return "".join(cleaned_sample)

    @staticmethod
    def sample_writer(path : str, sequence : str):
        sample = open(path, "w")
        sample.write(sequence)
        sample.close()


    @staticmethod
    def distance_species(initial_specie, hypotetic_specie) -> float:
        """
            Compare deux espèces et retourne leur distance.

            param proved_specie: Le premiere espece qui peut soit être une espèce avérée ou hypothétique
            param hypotetic_specie: Une espece hypothetique
        """
        sum = 0
        count = 0
        if isinstance(initial_specie, Espece_Averee):
            for child_specie in hypotetic_specie.enfants:
                count += 1
                sum += Echantillon.mutation_replacement_distance(initial_specie.get_sequence_adn(), child_specie.get_sequence_adn())

            return sum/count
        else:
            for initial_child_specie in initial_specie.enfants:  
                for child_specie in hypotetic_specie.enfants:
                    count += 1
                    sum += Echantillon.mutation_replacement_distance(initial_child_specie.get_sequence_adn(), child_specie.get_sequence_adn())
            return sum/count

def main():

    # Exemple d'utilisation
    echantillon = Echantillon.create_sequence(100)
    echantillon_replaced = Echantillon.mutation_replacement(echantillon, 0.2)
    echantillon_mutated = Echantillon.mutation(echantillon, 0.3, 0.1, 0.2)
    print(echantillon)
    print(echantillon_mutated)
    print(Echantillon.mutation_replacement_distance(echantillon, echantillon_replaced))
    print(Echantillon.levenshtein("chiens","niche"))

    rhinoceros = Espece_Averee("Rhinoceros", "Perissodactyla", "genome", "ACGTACGT")
    ferae = Espece_Hypothetique("Ferae", "Mamifère")
    ferae.add_enfants(Espece_Averee("Hyene", "Carnivora", "genome", "ACGTATGTA")) # 2 distance par rapport a Rhinoceros
    ferae.add_enfants(Espece_Averee("Tapir", "Pholidota", "genome", "ACGTATCGTA")) # 5 distance par rapport a Rhinoceros

    feralia = Espece_Hypothetique("Feralia", "Mamifère")
    feralia.add_enfants(Espece_Averee("Hyeneia", "Carnivora", "genome", "ACGTATGTABACG"))
    feralia.add_enfants(Espece_Averee("Tapirilia", "Pholidota", "genome", "TCGTATTGTA")) 

    print("distance espece rhino et ferae : ")
    print(Echantillon.distance_species(rhinoceros, ferae))
    print("distance espece rhino et ferae : ")
    print(Echantillon.distance_species(feralia, ferae))

if __name__ == "__main__":
    main() 